<!doctype html><html lang=de dir=ltr data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.7.0"><title data-rh=true>Programmieren mit Java</title><meta data-rh=true property=og:title content="Programmieren mit Java"><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://jappuccini.github.io/java-docs/production/slides/steffen/java-2/04-sort-algo><meta data-rh=true property=og:locale content=de><meta data-rh=true name=docusaurus_locale content=de><meta data-rh=true name=docusaurus_tag content=default><meta data-rh=true name=docsearch:language content=de><meta data-rh=true name=docsearch:docusaurus_tag content=default><link data-rh=true rel=icon href=/java-docs/production/img/favicon.ico><link data-rh=true rel=canonical href=https://jappuccini.github.io/java-docs/production/slides/steffen/java-2/04-sort-algo><link data-rh=true rel=alternate href=https://jappuccini.github.io/java-docs/production/slides/steffen/java-2/04-sort-algo hreflang=de><link data-rh=true rel=alternate href=https://jappuccini.github.io/java-docs/production/slides/steffen/java-2/04-sort-algo hreflang=x-default><link rel=stylesheet href=/java-docs/production/assets/css/styles.050393a2.css><script src=/java-docs/production/assets/js/runtime~main.3933c45d.js defer></script><script src=/java-docs/production/assets/js/main.da562a19.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:"light",document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div class="reveal reveal-viewport" style=width:100vw;height:100vh><div class=slides><section><section><h2>Sortieralgorithmen</h2></section><section><h2>Agenda</h2><ul><li class=fragment>Intro<li class=fragment>Selection Sort<li class=fragment>Bubble Sort<li class=fragment>Insertion Sort<li class=fragment>Quick Sort<li class=fragment>Merge Sort</ul></section></section><section><section><h2>Intro</h2></section><section><h2>Was ist Sortieren?</h2><p class=fragment>Neuordnung eines gegebenen Arrays oder einer Liste von Elementen nach einem Vergleichsoperator fÃ¼r die Elemente<p class=fragment>Alle Elemente werden entweder in aufsteigender oder in absteigender Reihenfolge neu angeordnet.</section><section><h2>Begriffe</h2><ul><li class=fragment tabindex=0 data-tooltip="Ein In-place Sortieralgorithmus tauscht Elemente innerhalb der Liste aus.">In-place sorting<li class=fragment tabindex=0 data-tooltip="Der komplette Input wird im lokalen Speicher gehalten. Der Input kann nicht grÃ¶ÃŸer sein als der lokale Speicher.">Internal Sorting<li class=fragment tabindex=0 data-tooltip="Der komplette Input muss nicht im lokalen Speicher gehalten werden. Der Input kann grÃ¶ÃŸer sein als der lokale Speicher.">External Sorting<li class=fragment tabindex=0 data-tooltip="Falls zwei Elemente 'gleich' sind, wird die ursprÃ¼ngliche Reihenfolge beibehalten.">Stable Sorting<li class=fragment tabindex=0 data-tooltip="Falls zwei Elemente 'gleich' sind, wird die ursprÃ¼ngliche Reihenfolge nicht beibehalten.">Unstable Sorting</ul></section><section><h2>Stable und Unstable Sorting</h2><ul><li class=fragment>ğŸƒ… ğŸƒ• ğŸ‚² ğŸ‚ª â†’ Input<li class=fragment>ğŸ‚² ğŸƒ… ğŸƒ• ğŸ‚ª â†’ Stabil<li class=fragment>ğŸ‚² ğŸƒ• ğŸƒ… ğŸ‚ª â†’ Unstabil</ul><p class="foot-note fragment">Ein stabiler Sortieralgorithmus verÃ¤ndert nicht die ursprÃ¼ngliche Reihenfolge der 5er-Karten</section><section><h2>Anwendungen von Sortieralgorithmen</h2><ul><li tabindex=0 data-tooltip="BinÃ¤rsuche, Interpolationssuche etc.">Suchalgorithmen<li tabindex=0 data-tooltip="Abfragen, Indizes etc.">Datenbankoptimierung<li tabindex=0 data-tooltip="Muster, Trends etc.">Datenanalyse<li tabindex=0 data-tooltip="Scheduler, Arbeitsspeicherverwaltung etc.">Betriebssysteme</ul></section></section><section><section><h2>Selection Sort</h2></section><section><h2>Funktionsweise</h2><p>Beim Selection Sort wird wiederholt das kleinste Element aus dem unsortierten Teil der Liste ausgewÃ¤hlt und in den sortierten Teil der Liste verschoben.<p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</section><section><h2>Theoretisches Konzept</h2><ul><li class=fragment>Man setzt den Index auf Low<li class=fragment>Man durchsucht den restlichen Teil des Arrays nach dem kleinsten Element<li class=fragment>Man tauscht das kleinste Element mit dem Element am Index<li class=fragment>Index inkrementieren und wiederholen solange, bis alle Elemente sortiert sind.</ul></section><section><h2><a href=https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/SelectionSort.java target=_blank rel="noopener noreferrer">Demo - Selection Sort</a></h2></section><section><h2>Performance</h2><ul><li class=fragment>ZeitkomplexitÃ¤t: O(NÂ²)<li class=fragment>SpeicherkomplexitÃ¤t: O(1)</ul></section><section><h2>Zusammenfassung</h2><ul><li class=fragment>Einfach zu implementieren<li class=fragment data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸƒ” ğŸ‚´ ğŸ‚µ ğŸ‚¶  " tabindex=0>Nicht stabil</ul></section></section><section><section><h2>Bubble Sort</h2></section><section><h2>Funktionsweise</h2><p>Beim Bubble Sort wird wiederholt das grÃ¶ÃŸte Element aus dem unsortierten Teil der Liste in den sortierten Teil der Liste verschoben.<p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</section><section><h2>Theoretisches Konzept</h2><ul><li class=fragment>Man setzt den Index auf Low<li class=fragment>Man durchlÃ¤uft den unsortierten Teil des Arrays<!-- --> <li class=fragment>Ist das aktuelle Element am Index grÃ¶ÃŸer als das nÃ¤chste Element, werden Sie getauscht.<li class=fragment>High dekrementieren und wiederholen solange, bis alle Elemente sortiert sind.</ul></section><section><h2><a href=https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/BubbleSort.java target=_blank rel="noopener noreferrer">Demo - Bubble Sort</a></h2></section><section><h2>Performance</h2><ul><li class=fragment>ZeitkomplexitÃ¤t: O(NÂ²)<li class=fragment>SpeicherkomplexitÃ¤t: O(1)</ul></section><section><h2>Zusammenfassung</h2><ul><li class=fragment>Einfach zu implementieren<li class=fragment data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex=0>Stabil</ul></section></section><section><section><h2>Insertion Sort</h2></section><section><h2>Funktionsweise</h2><p>Beim Insertion Sort wird wiederholt das nÃ¤chste Element aus dem unsortierten Teil der Liste in die richtige Stelle des sortierten Teils der Liste verschoben.<p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</section><section><h2>Theoretisches Konzept</h2><ul><li class=fragment data-tooltip="Das erste Element ist immer schon sortiert." tabindex=0>Man setzt den sortedHighIndex auf Low + 1<li class=fragment>Man durchlÃ¤uft den unsortierten Teil des Arrays<li class=fragment>Ist das aktuelle Element am Index kleiner als das vorherige Element, werden Sie getauscht.<li class=fragment>sortedHigh dekrementieren und wiederholen solange, bis Element an der richtigen Stelle sortiert ist</ul></section><section><h2><a href=https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/InsertionSort.java target=_blank rel="noopener noreferrer">Demo - Insertion Sort</a></h2></section><section><h2>Performance</h2><ul><li class=fragment>ZeitkomplexitÃ¤t: O(NÂ²)<li class=fragment>SpeicherkomplexitÃ¤t: O(1)</ul></section><section><h2>Zusammenfassung</h2><ul><li class=fragment>Einfach zu implementieren<li class=fragment data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex=0>Stabil</ul></section></section><section><section><h2>Quick Sort</h2></section><section><h2>Allgemein</h2><ul><li class=fragment>Divide and Conquer<li class=fragment>Rekursiv</ul></section><section><h2>Funktionsweise</h2><p class=fragment>Beim Quick Sort wird wiederholt der Input am freiwÃ¤hlbaren Pivotindex aufgeteilt. Jedes Element wird mit dem Pivotelement verglichen. Ist es kleiner als das Pivotelement wird es in den linken Teil verschoben, ansonsten in den rechten Teil.<p class=fragment>AnschlieÃŸend wird zuerst der linke Teil danach der rechte Teil sortiert.<p class="foot-note fragment">Beispiel: 10, 80, 30, 90, 40, 50, 70</section><section><h2>Theoretisches Konzept</h2><ul><li class=fragment>Base Case: Nur noch 1 Element Ã¼brig â†’ return;<li class=fragment>Pre Recurse: Aufteilen des Arrays in Links und Rechts<li class=fragment>Recurse: linke Seite anschlieÃŸend rechte Seite</ul></section><section><h2><a href=https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/QuickSort.java target=_blank rel="noopener noreferrer">Demo - Quick Sort</a></h2></section><section><h2>Performance</h2><ul><li class=fragment>ZeitkomplexitÃ¤t: O(NÂ²)<li class=fragment>SpeicherkomplexitÃ¤t: O(1)</ul></section><section><h2>Zusammenfassung</h2><ul><li class=fragment data-tooltip="Bei Best und Average Case, meistens zwischen Average und Worst Case" tabindex=0>Effizient bei groÃŸen Datenmengen O(N log N)<li class=fragment data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex=0>Nicht stabil</ul></section></section><section><section><h2>Merge Sort</h2></section><section><h2>Allgemein</h2><ul><li class=fragment>Divide and Conquer<li class=fragment>Rekursiv</ul></section><section><h2>Funktionsweise</h2><p class=fragment>Beim Merge Sort wird wiederholt der Input in der Mitte aufgeteilt.<p class=fragment>AnschlieÃŸend wird zuerst der linke Teil danach der rechte Teil sortiert.<p class=fragment>AnschlieÃŸend werden der linke und der rechte Teil zusammengefÃ¼hrt.<p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</section><section><h2>Theoretisches Konzept</h2><ul><li class=fragment>Base Case: Nur noch 1 Element Ã¼brig â†’ return;<li class=fragment>Pre Recurse: Aufteilen des Arrays in Links und Rechts<li class=fragment>Recurse: linke Seite anschlieÃŸend rechte Seite<li class=fragment>Post Recurse: linke Seite und rechte Seite zusammenfÃ¼hren</ul></section><section><h2><a href=https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/MergeSort.java target=_blank rel="noopener noreferrer">Demo - Merge Sort</a></h2></section><section><h2>Performance</h2><ul><li class=fragment>ZeitkomplexitÃ¤t: O(N log N)<li class=fragment>SpeicherkomplexitÃ¤t: O(N)</ul></section><section><h2>Zusammenfassung</h2><ul><li class=fragment data-tooltip="Immer ğŸš€" tabindex=0>Effizient bei groÃŸen Datenmengen O(N log N)<li class=fragment data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex=0>Stabil<li class=fragment data-tooltip="Es wird immer temporÃ¤r ein Kopie der Subarrays erstellt" tabindex=0>Speicherbedarf is Hoch<li class=fragment data-tooltip="Es wird immer eine Kopie erstellt und anschlieÃŸend Ã¼berschrieben" tabindex=0>Kein In-Place Sort</ul></section></section><section><section><h2>Vergleich Sortieralgorithmen</h2></section><section><table><thead><tr><th>Algorithmus<th>Best <th>Average <th>Worst <tbody><tr class=fragment><td>Selection Sort<td>O(NÂ²)<td>O(NÂ²)<td>O(NÂ²)<tr class=fragment><td>Bubble Sort<td>O(N)<td>O(NÂ²)<td>O(NÂ²)<tr class=fragment><td>Insertion Sort<td>O(N)<td>O(NÂ²)<td>O(NÂ²)<tr class=fragment><td>Quick Sort<td>O(N log N)<td>O(N log N)<td>O(NÂ²)<tr class=fragment><td>Merge Sort<td>O(N log N)<td>O(N log N)<td>O(N log N)</table><p class="fragment foot-note">Merge Sort hat eine SpeicherkomplexitÃ¤t von O(N)</section></section><section><h2>Rest of the day</h2><ul><li class=fragment>Demo Code verstehen, debuggen, implementieren (Optional)<li class=fragment>Sort mit eigenem Problem (Optional)</ul></section></div></div></div>