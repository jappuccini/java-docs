---
title: 2025
description: ''
sidebar_position: 40
tags: []
---

## Aufgabe 1 - Optional

Implementiere die Klassen Driver und Task01.

### Klassendiagramm

```mermaid
classDiagram

  Car -- Task01
  Car o-- Driver

  class Car {
    <<record>>
    +make: String
    +model: String
    +owner: Driver
  }

  class Driver {
    +name: String
    +driverLicence: Optional~String~
    +Driver(name: String)
    +Driver(name: String, driverLicence: String)
    +toString() String
    +isAllowedToDrive() boolean
  }

  class Task01 {
    +main(args: String[])void$
  }
```

```java
public record Car (String make, String model, Driver owner) {}
```

### Hinweise zur Klasse Driver

- Die Konstruktoren sollen alle Attribute initialisieren. Verwende die korrekten
  Methoden der Optional Klasse, sodass kein Fehler ausgelöst wird, falls eine
  Null Referenz für driverLicence übergeben wird.

- Die Methode **toString** soll das Objekt als String zurückgeben. Es sollen nur
  die Attribute berücksichtigt werden, welche einen Wert haben. Haben beide
  Attribute einen Wert, sollen die Werte durch ein Leerzeichen getrennt werden.
  Es sollen ausschließlich die **Werte** ausgegeben werden.

  Beispiel:

  ```
  Steffen
  Steffen B
  ```

- Die Methode **isAllowedToDrive** soll ermitteln, ob der Fahrer die
  Führerscheinklasse B hat.

### Hinweise zur Klasse Task01

Es soll ein Auto der Marke BMW und dem Modell 320i erstellt werden. Der
Eigentümer des Autos soll den Namen "Steffen" haben, der keinen Führerschein
hat. Gib anschließend den **Eigentümer** des Autos in der Konsole aus. Lege die
Führerscheinklasse des zuvor angelegten Eigentümers auf "B" fest. Falls der
Fahrer anschließend das Auto fahren darf, soll das Auto auf der Konsole
ausgegeben werden.

### Lösung

```java
public class Driver {
    public String name;
    public Optional<String> driverLicence;

    public Driver(String name) {
        this(name, null);
    }

    public Driver(String name, String driverLicence) {
        this.name = name;
        this.driverLicence = Optional.ofNullable(driverLicence);
    }

    public String toString() {
        if (driverLicence.isPresent()) {
            return String.join(" ", name, driverLicence.get());
        } else {
            return this.name;
        }
    }

    public boolean isAllowedToDrive() {
        return driverLicence.isPresent() && driverLicence.get().equals("B");
    }
}

public class Task01 {
    public static void main(String[] args) {
        Car car = new Car("BMW", "320i", new Driver("Steffen"));
        System.out.println(car.owner());
        car.owner().driverLicence = Optional.of("B");
        if (car.owner().isAllowedToDrive()) {
            System.out.println(car);
        }
    }
}
```

## Aufgabe 2 - Lambdafunktionen

Implementiere die Klassen Game und Task02.

### Klassendiagramm

```mermaid
classDiagram
  Game -- Task02

  class Usk {
    <<enum>>
    0, 6, 12, 16 18;

    getChildUsks()$ List~Usk~

  }

  class Game {
      <<record>>
      +name String
      +usk Usk
      +price double
      +isForChilds ?$
      +makeRemaster ?$

      +isCheaperThan(price: double)$ Predicate~Game~
      +getGames()$ Stream~Game~
  }

  class Task02 {
      +main(args: String[])$ void
  }
```

```java
import java.util.List;

public enum Usk {
    ZERO,
    SIX,
    TWELVE,
    SIXTEEN,
    EIGHTEEN;


    public static List<Usk> getChildUsks() {
        return List.of(Usk.ZERO, Usk.SIX);
    }
}
```

Im Klassendiagramm sind nicht alle Datentypen angegeben. Verwende für alle
fehlenden Datentypen ein passendes funktionales Interface.

- Das Attribut **isForChilds** soll eine Lambdafunktion enthalten, die
  ermittelt, ob die Usk eines Spiels für Kinder ist. Die Usk Klasse definiert
  alle Child Usk.

- Das Attribut **makeRemaster** soll eine Lambdafunktion enthalten, die ein
  bestehendes Spiel in eine Remaster Version umwandelt. Bei der Umwandlung soll
  der Titel "Remastered" als Suffix enthalten und der Preis um 50% erhöht
  werden.

- Die Methode **isCheaperThan** soll eine Lambdafunktion zurückgeben, die
  abhängig von den Parametern überprüft, ob ein Spiel günstiger als der
  Parameter ist.

- Die Methode **getGames** soll einen Stream von einem einzelnen Game mit frei
  gewählten Werten zurückgeben.

### Hinweise zur Klasse Task02

Verwende für die nachfolgende Abfolge die Methoden der Klasse Game.

Erzeuge einen Stream von Spielen und mache Sie zu Remastered Versionen. Verwende
einen Filter, sodass nur Spiele übrig bleiben, welche für Kinder geeignet sind
und günstiger als 70 sind.

### Lösung

```java
public record Game(String name, Usk usk, double price) {

    public static Predicate<Game> isForChilds = g -> Usk.getChildUsks().contains(g.usk);

    public static Function<Game, Game> makeRemaster = g -> new Game(g.name() + " Remastered", g.usk(), g.price * 1.5);

    public static Predicate<Game> isCheaperThan(double price) {
        return g -> g.price() < price;
    }

    public static Stream<Game> getGames() {
        return Stream.of(new Game("Doom Eternal", Usk.EIGHTEEN, 59.99));
    }
}

public class Task02 {
    public static void main(String[] args) {
        Game.getGames()
                .map(Game.makeRemaster)
                .filter(Game.isForChilds)
                .filter(Game.isCheaperThan(70));
    }
}
```

## Aufgabe 3 - Streams

Implementiere die Klassen Employee, Customer und Company.

### Klassendiagramm

```mermaid
classDiagram
  direction TB

  Company -- Employee
  Company -- Customer

  class Employee {
    <<record>>
    +name: String
    +salary: double
    +skills : List~String~
  }

  class Customer {
    <<record>>
    +name: String
    +yearOfFirstOrder: int
    +orders: Map~Integer, Double~
  }

  class Company {
    <<record>>
    +customers: List~Customer~
    +employees: List~Employee~

    +q1() double
    +q2() void
    +q3() Map~Character&sbquo; List~Employee~~
    +q4(skill: String) Optional~Employee~
    +q5() List~String~
  }

```

### Hinweise zur Klasse Employee

Jeder Mitarbeiter kann durch einen Namen, das Jahresgehalt und seine Skills
beschrieben werden.

### Hinweise zur Klasse Customer

Jeder Kunde kann durch einen Namen, das Jahr der ersten Bestellung und seine
Bestellungen beschrieben werden. Der Schlüssel entspricht der Bestellnummer und
der Wert der Map der Bestellsumme.

### Hinweise zur Klasse Company

Das Unternehmen enthält Mitarbeiter (employees) und Kunden (customers). Benutze
die Java Stream API, um die Anforderungen des CEO's zu erfüllen.

- **q1** Der CEO möchte wissen, was für ein Durchschnittsgehalt seine Entwickler
  für Smartphones haben.

  Die Methode soll das Durchschnittsgehalt der Mitarbeiter ermitteln, welche
  "Java", "Kotlin" oder "Swift" als Skill haben.

- **q2** Der CEO ist in Boni Laune und will seinen 3 "besten" "Mitarbeitern"
  eine Reise auf die Malediven schenken.

  Die Methode soll die drei Sales-Mitarbeiter ermitteln, welche am besten
  Verdienen und einen persönlichn Gruß auf der Konsole ausgeben:

  Beispiel:

  ```
  Ein kleines Danke Mirco! Viel Spaß in der Sonne.
  ```

  Ein Mitarbeiter gilt als Sales-Mitarbeiter, sofern er den Skill "Sales" hat.

- **q3** Der CEO leidet unter Kontrollwahn. Er will wissen wie viele Mitarbeiter
  "KI" nicht kennen und nach Alter gruppieren. Er glaubt, dass Boomer KI nicht
  nutzen.

  Die Methode soll ermittlen, wieviele Mitarbeiter den Skill "KI" nicht haben
  und diese nach dem ersten Buchstaben des Namens gruppieren.

- **q4** Der CEO ist in Kündigungslaune und möchte Experten herausfinden, welche
  durch KI ersetzt werden können. Abhänging vom Parameter skill soll der
  Mitarbeiter mit der teuersten Salary/Skill Ratio gefunden werden.

  Die Methode soll einen Mitarbeiter zurückgeben. Zuerst sollen jene
  **Mitarbeiter** ermittelt werden, die den Parameter skill haben. Anschließend
  soll der teuerste Mitarbeiter ermittelt werden. Der Wert des Mitarbeiters wird
  wie folgt berechnet: Jahresgehalt / Anzahl an Skills.

- **q5** Der CEO will kurzfristig die Dividende erhöhen und will sein
  Unternehmen in ein Premiumunternehmen umwandeln. Alle Kunden, die eine
  Bestellung mit einer geringen Summe haben sollen gesperrt werden.

  Die Methode soll alle Kunden ermitteln, welche eine Bestellung haben deren
  Bestellsumme geringer als 100 ist und deren Namen in Großbuchstaben
  zurückgeben. Die Liste soll keine doppelten Werte enthalten.

### Lösung

```java
public record Employee(String name, double salary, List<String> skills) {}
public record Customer(String name, int yearOfFirstOrder, Map<Integer, Double> orders) {}

public record Company(List<Customer> customers, List<Employee> employees) {
    public double q1() {
        return employees().stream()
                .filter(employee -> employee.skills().stream()
                        .anyMatch(skill -> List.of("Java", "Kotlin", "Swift")
                                .contains(skill)))
                .mapToDouble(employees -> employees.salary())
                .average().orElse(0);
    }

    public void q2() {
        employees().stream()
                .filter(employee -> employee.skills().contains("Sales"))
                .sorted((e1, e2) -> Double.compare(e2.salary(), e1.salary()))
                .limit(3)
                .map(employee -> "Danke " + employee.name() + ". Top Man du seller!")
                .forEach(System.out::println);
    }

    public Map<Character, List<Employee>> q3() {
        return employees().stream()
                .filter(e -> !e.skills().contains("KI"))
                .collect(Collectors.groupingBy(e -> e.name().charAt(0)));
    }

    public Optional<Employee> q4(String skill) {
        return employees().stream()
                .filter(e -> e.skills().contains(skill))
                .max((e1, e2) -> {
                    double r1 = e1.salary() / e1.skills().size();
                    double r2 = e2.salary() / e2.skills().size();
                    return Double.compare(r1, r2);
                });
        // .max(Comparator.comparingDouble(e -> e.salary() / e.skills().size()));
    }

    public List<String> q5() {
        return customers.stream()
                .filter(c -> c.orders().values().stream().anyMatch(sum -> sum < 100))
                .map(c -> c.name().toUpperCase())
                .distinct()
                .toList();
    }
}
```
