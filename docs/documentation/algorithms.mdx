---
title: Algorithmen
description: ''
sidebar_position: 350
tags: [algorithms]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::danger Hinweis

ToDo

:::

## Suchalgorithmen

Suchalgorithmen sollen innerhalb einer Datensammlung einen oder mehrere
DatensÃ¤tze mit bestimmten Eigenschaften finden. Zu den wichtigen Suchalgorithmen
zÃ¤hlen die Linearsuche, die BinÃ¤rsuche sowie die Interpolationssuche.

<Tabs>
  <TabItem value="linearSearch" label="Linearsuche" default>

Bei der Linearsuche werden alle EintrÃ¤ge einer Datensammlung nacheinander
durchlaufen, d.h. eine Suche kann im besten Fall (Best Case) beim ersten Eintrag
und im schlechtesten Fall beim letzten Eintrag beendet sein. Bei einer
erfolglosen Suche mÃ¼ssen alle EintrÃ¤ge durchlaufen werden.

Im nachfolgenden Beispiel wird die Zahlenfolge
`12, 16, 36, 49, 50, 68, 70, 76, 99` nach dem Wert 70 durchsucht.

| Index | 1      | 2      | 3      | 4      | 5      | 6      | 7      |
| ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 0     | **12** | **12** | **12** | **12** | **12** | **12** | **12** |
| 1     | 16     | **16** | **16** | **16** | **16** | **16** | **16** |
| 2     | 36     | 36     | **36** | **36** | **36** | **36** | **36** |
| 3     | 49     | 49     | 49     | **49** | **49** | **49** | **49** |
| 4     | 50     | 50     | 50     | 50     | **50** | **50** | **50** |
| 5     | 68     | 68     | 68     | 68     | 68     | **68** | **68** |
| 6     | 70     | 70     | 70     | 70     | 70     | 70     | **70** |
| 7     | 76     | 76     | 76     | 76     | 76     | 76     | 76     |
| 8     | 99     | 99     | 99     | 99     | 99     | 99     | 99     |

:::note Hinweis

Durch vorheriges Sortieren der Sammlung kann die Leistung des Algorithmus
verbessert werden.

:::

  </TabItem>
  <TabItem value="binarySearch" label="BinÃ¤rsuche">

Bei der BinÃ¤rsuche wird die sortierte Sammlung schrittweise halbiert.
AnschlieÃŸend wird nur noch in der jeweils passenden HÃ¤lfte weitergesucht. Die
BinÃ¤rsuche folgt damit dem Teile-und-Herrsche-Prinzip und ist i.d.R. schneller
als die Linearsuche, setzt aber eine sortierte Sammlung voraus.

Im nachfolgenden Beispiel wird die Zahlenfolge
`12, 16, 36, 49, 50, 68, 70, 76, 99` nach dem Wert 70 durchsucht.

| Index | 1    | 2      |
| ----- | ---- | ------ |
| 0     | 12   | **12** |
| 1     | 16   | **16** |
| 2     | 36   | **36** |
| 3     | 49   | **49** |
| 4     | [50] | **50** |
| 5     | 68   | 68     |
| 6     | 70   | [70]   |
| 7     | 76   | 76     |
| 8     | 99   | 99     |

| Durchlauf | l   | r   | m   |
| --------- | --- | --- | --- |
| 1         | 0   | 8   | 4   |
| 2         | 5   | 8   | 6   |

:::note Legende

l = linke Grenze, r = rechte Grenze, m = Mitte

:::

:::note Hinweis

Bei der Ermittlung der Mitte wird i.d.R. die Abrundungsfunktion verwendet, d.h.
zu einer reellen Zahl wird die grÃ¶ÃŸte ganze Zahl, die kleiner als die reelle
Zahl ist, verwendet.

:::

  </TabItem>
  <TabItem value="interpolationSearch" label="Interpolationsuche">

Die Interpolationssuche basiert auf der BinÃ¤rsuche, halbiert die Sammlung aber
nicht, sondern versucht, durch Interpolation, einen geeigneteren Teiler zu
ermitteln. Dieser wird mit Hilfe der Formel
`t = âŒŠğ‘™ + ((ğ‘  âˆ’ ğ‘‘[ğ‘™]) / (ğ‘‘[ğ‘Ÿ] âˆ’ ğ‘‘[ğ‘™])) âˆ— (ğ‘Ÿ âˆ’ ğ‘™)âŒ‹` ermittelt.

Im nachfolgenden Beispiel wird die Zahlenfolge
`12, 16, 36, 49, 50, 68, 70, 76, 99` nach dem Wert 70 durchsucht.

| Index | 1    | 2      |
| ----- | ---- | ------ |
| 0     | 12   | **12** |
| 1     | 16   | **16** |
| 2     | 36   | **36** |
| 3     | 49   | **49** |
| 4     | 50   | **50** |
| 5     | [68] | **68** |
| 6     | 70   | [70]   |
| 7     | 76   | 76     |
| 8     | 99   | 99     |

| Durchlauf | s   | l   | r   | d[l] | d[r] | t   |
| --------- | --- | --- | --- | ---- | ---- | --- |
| 1         | 70  | 0   | 8   | 12   | 99   | 5   |
| 2         | 70  | 6   | 8   | 70   | 99   | 6   |

:::note Legende

ğ‘  = SchlÃ¼ssel, ğ‘™ = linke Grenze, ğ‘Ÿ = rechte Grenze, ğ‘‘ = Datensammlung, t =
Teiler, âŒŠ âŒ‹ = untere GauÃŸklammer

:::

  </TabItem>
</Tabs>

## Sortieralgorithmen

Sortieralgorithmen sollen eine mÃ¶glichst effiziente Speicherung von Daten und
deren Auswertung ermÃ¶glichen. Man unterscheidet dabei zwischen einfachen und
rekursiven Sortieralgorithmen.

<Tabs>
  <TabItem value="bubbleSort" label="Bubblesort" default>

Der Bubblesort verfolgt die Idee, das grÃ¶ÃŸere Blasen schneller aufsteigen als
kleinere. Dementsprechend werden beim Bubblesort Nachbarelemente miteinander
verglichen und gegebenenfalls vertauscht, so dass am Ende eines Durchlaufs das
jeweils grÃ¶ÃŸte Element am Ende des noch unsortierten Teils steht.

| Index | 0   | 1      | 2      | 3      | 4      | 5      | 6      | 7      | 8      | 9      |
| ----- | --- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 0     | 12  | 12     | 12     | 12     | 12     | 12     | 12     | 12     | 12     | **12** |
| 1     | 99  | 50     | 50     | 36     | 36     | 36     | 36     | 16     | **16** | **16** |
| 2     | 50  | 68     | 36     | 49     | 49     | 49     | 16     | **36** | **36** | **36** |
| 3     | 68  | 36     | 49     | 50     | 50     | 16     | **49** | **49** | **49** | **49** |
| 4     | 36  | 49     | 68     | 68     | 16     | **50** | **50** | **50** | **50** | **50** |
| 5     | 49  | 76     | 70     | 16     | **68** | **68** | **68** | **68** | **68** | **68** |
| 6     | 76  | 70     | 16     | **70** | **70** | **70** | **70** | **70** | **70** | **70** |
| 7     | 70  | 16     | **76** | **76** | **76** | **76** | **76** | **76** | **76** | **76** |
| 8     | 16  | **99** | **99** | **99** | **99** | **99** | **99** | **99** | **99** | **99** |

  </TabItem>
  <TabItem value="insertSort" label="Insertsort">

Beim Insertsort (auch Insertion Sort) wird dem unsortierten Teil der
Ausgangsdaten ein beliebiges Element entnommen (z.B. das jeweils erste) und an
der richtigen Stelle im sortierten Teil wieder eingefÃ¼gt. Beim EinfÃ¼gen wird das
entnommene Element mit den bereits sortierten Elementen verglichen.

| Index | 0   | 1      | 2      | 3      | 4      | 5      | 6      | 7      | 8      | 9      |
| ----- | --- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 0     | 12  | **12** | **12** | **12** | **12** | **12** | **12** | **12** | **12** | **12** |
| 1     | 99  | 99     | **99** | **50** | **50** | **36** | **36** | **36** | **36** | **16** |
| 2     | 50  | 50     | 50     | **99** | **68** | **50** | **49** | **49** | **49** | **36** |
| 3     | 68  | 68     | 68     | 68     | **99** | **68** | **50** | **50** | **50** | **49** |
| 4     | 36  | 36     | 36     | 36     | 36     | **99** | **68** | **68** | **68** | **50** |
| 5     | 49  | 49     | 49     | 49     | 49     | 49     | **99** | **76** | **70** | **68** |
| 6     | 76  | 76     | 76     | 76     | 76     | 76     | 76     | **99** | **76** | **70** |
| 7     | 70  | 70     | 70     | 70     | 70     | 70     | 70     | 70     | **99** | **76** |
| 8     | 16  | 16     | 16     | 16     | 16     | 16     | 16     | 16     | 16     | **99** |

  </TabItem>
  <TabItem value="selectSort" label="Selectsort">

Beim Selectsort (auch Selection Sort) wird dem unsortierten Teil der
Ausgangsdaten das jeweils kleinste Element entnommen und dem sortierten Teil
angehÃ¤ngt.

| Index | 0   | 1      | 2      | 3      | 4      | 5      | 6      | 7      | 8      | 9      |
| ----- | --- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 0     | 12  | **12** | **12** | **12** | **12** | **12** | **12** | **12** | **12** | **12** |
| 1     | 99  | 99     | **16** | **16** | **16** | **16** | **16** | **16** | **16** | **16** |
| 2     | 50  | 50     | 99     | **36** | **36** | **36** | **36** | **36** | **36** | **36** |
| 3     | 68  | 68     | 50     | 99     | **49** | **49** | **49** | **49** | **49** | **49** |
| 4     | 36  | 36     | 68     | 50     | 99     | **50** | **50** | **50** | **50** | **50** |
| 5     | 49  | 49     | 36     | 68     | 50     | 99     | **68** | **68** | **68** | **68** |
| 6     | 76  | 76     | 49     | 49     | 68     | 68     | 99     | **70** | **70** | **70** |
| 7     | 70  | 70     | 76     | 76     | 76     | 76     | 76     | 99     | **76** | **76** |
| 8     | 16  | 16     | 70     | 70     | 70     | 70     | 70     | 76     | 99     | **99** |

  </TabItem>
  <TabItem value="quickSort" label="Quicksort">

Beim Quicksort wird die jeweilige Sammlung anhand eines beliebigen Elements
(i.d.R. das mittlere Element) in zwei HÃ¤lften aufgeteilt: eine HÃ¤lfte mit
Elementen kleiner oder gleich dem Teiler-Element und eine HÃ¤lfte mit Elementen
grÃ¶ÃŸer dem Teiler-Element. Der Quicksort setzt folglich auf das
Teile-und-Herrsche-Prinzip.

| Index | 0    | 1    | 2      | 3      | 4      | 5      | 6      |
| ----- | ---- | ---- | ------ | ------ | ------ | ------ | ------ |
| 0     | 12   | 12   | **12** | **12** | **12** | **12** | **12** |
| 1     | 99   | [16] | **16** | **16** | **16** | **16** | **16** |
| 2     | 50   | 36   | **36** | **36** | **36** | **36** | **36** |
| 3     | 68   | _68_ | 68     | **49** | **49** | **49** | **49** |
| 4     | [36] | _50_ | 50     | 50     | 50     | **50** | **50** |
| 5     | 49   | _49_ | [49]   | 68     | [68]   | **68** | **68** |
| 6     | 76   | _76_ | 76     | [76]   | 70     | **70** | **70** |
| 7     | 70   | _70_ | 70     | 70     | _76_   | [76]   | **76** |
| 8     | 16   | _99_ | 99     | 99     | _99_   | 99     | **99** |

| Durchlauf | l   | r   | m   | d[m] | i   | j   | l-j | i-r |
| --------- | --- | --- | --- | ---- | --- | --- | --- | --- |
| 1         | 0   | 8   | 4   | 36   | 3   | 2   | 0-2 | 3-8 |
| 2         | 0   | 2   | 1   | 16   | 2   | 0   | 0-0 | 2-2 |
| 3         | 3   | 8   | 5   | 49   | 4   | 3   | 3-3 | 4-8 |
| 4         | 4   | 8   | 6   | 76   | 7   | 6   | 4-6 | 7-8 |
| 5         | 4   | 6   | 5   | 68   | 6   | 4   | 4-4 | 6-6 |
| 6         | 7   | 8   | 7   | 76   | 8   | 6   | 7-6 | 8-8 |

:::note Legende

l = linke Grenze, r = rechte Grenze, m = Mitte, d = Datensammlung, i = linker
Index, j = rechter Index

:::

:::note Hinweis

Bei der Ermittlung der Mitte wird i.d.R. die Abrundungsfunktion verwendet, d.h.
zu einer reellen Zahl wird die grÃ¶ÃŸte ganze Zahl, die kleiner als die reelle
Zahl ist, verwendet.

:::

  </TabItem>
  <TabItem value="mergeSort" label="Mergesort">

Beim Mergesort wird die Ausgangsliste zunÃ¤chst in kleinere Listen zerlegt, die
anschlieÃŸend im ReiÃŸverschlussverfahren wieder zusammengefÃ¼gt bzw. verschmolzen
werden.

```mermaid
flowchart
    split0 --> split1
    split0 --> split2
    split1 --> split11
    split1 --> split12
    split11 --> split111
    split11 --> split112
    split2 --> split21
    split2 --> split22

    split111 --> merge1
    split112 --> merge12
    merge1 --> merge2
    merge12 --> merge2
    merge2 --> merge3
    split12 --> merge0
    merge0 --> merge3
    split21 --> merge4
    split22 --> merge5
    merge4 --> merge6
    merge5 --> merge6
    merge3 --> merge7
    merge6 --> merge7

    subgraph split
        split0(12, 99, 50, 68, 36, 49, 76, 70, 16)
        split1(12, 99, 50, 68, 36)
        split2(49, 76, 70, 16)
        split11(12, 99, 50)
        split111(12, 99)
        split112(50)
        split12(68, 36)
        split21(49, 76)
        split22(70, 16)
    end

    subgraph merge
        merge1(12, 99)
        merge12(50)
        merge2(12, 50, 99)
        merge0(36, 68)
        merge3(12, 36, 50, 68, 99)
        merge4(49, 76)
        merge5(16, 70)
        merge6(16, 49, 70, 76)
        merge7(12, 16, 36, 49, 50, 68, 70, 76, 99)
    end
```

  </TabItem>
</Tabs>

## KomplexitÃ¤t von Algorithmen

Da der Zeitaufwand von Algorithmen aufgrund unterschiedlicher Faktoren
(Hardware, parallele Verarbeitung, Eingabereihenfolge,â€¦) nicht genau ermittelt
werden kann, wird diese mit Hilfe der Landau-Notation dargestellt. Diese teilt
Algorithmen in unterschiedliche KomplexitÃ¤tsklassen (logarithmisch, linear,
polynomial,â€¦) ein. Die KomplexitÃ¤t einer Klasse ergibt sich dabei aus der Anzahl
der Schritte, die abhÃ¤ngig von der GrÃ¶ÃŸe der Eingangsvariablen ausgefÃ¼hrt werden
mÃ¼ssen.

| Algorithmus         | Best Case        | Average Case     | Worst Case       |
| ------------------- | ---------------- | ---------------- | ---------------- |
| Linearsuche         | ğ’ª(1)             | ğ’ª(ğ‘›)             | ğ’ª(ğ‘›)             |
| BinÃ¤rsuche          | ğ’ª(1)             | ğ’ª(ğ‘™ğ‘œğ‘” â¡ğ‘›)        | ğ’ª(ğ‘™ğ‘œğ‘” â¡ğ‘›)        |
| Interpolationssuche | ğ’ª(1)             | ğ’ª(ğ‘™ğ‘œğ‘” ğ‘™ğ‘œğ‘” â¡ğ‘›)    | ğ’ª(ğ‘›)             |
| Bubblesort          | ğ’ª(ğ‘›<sup>2</sup>) | ğ’ª(ğ‘›<sup>2</sup>) | ğ’ª(ğ‘›<sup>2</sup>) |
| Insertsort          | ğ’ª(ğ‘›)             | ğ’ª(ğ‘›<sup>2</sup>) | ğ’ª(ğ‘›<sup>2</sup>) |
| Selectsort          | ğ’ª(ğ‘›<sup>2</sup>) | ğ’ª(ğ‘›<sup>2</sup>) | ğ’ª(ğ‘›<sup>2</sup>) |
| Quicksort           | ğ’ª(ğ‘› ğ‘™ğ‘œğ‘” â¡ğ‘›)      | ğ’ª(ğ‘› ğ‘™ğ‘œğ‘” â¡ğ‘›)      | ğ’ª(ğ‘›<sup>2</sup>) |
| Mergesort           | ğ’ª(ğ‘› ğ‘™ğ‘œğ‘” â¡ğ‘›)      | ğ’ª(ğ‘› ğ‘™ğ‘œğ‘” â¡ğ‘›)      | ğ’ª(ğ‘› ğ‘™ğ‘œğ‘” â¡ğ‘›)      |

:::note Hinweis

Das Landau-Symbol ğ’ª steht fÃ¼r _Ordnung von_.

:::
