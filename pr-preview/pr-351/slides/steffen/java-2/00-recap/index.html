<!doctype html><html lang=de dir=ltr data-has-hydrated=false><head><meta charset=UTF-8><meta name=generator content="Docusaurus v3.9.2"><title data-rh=true>Programmieren mit Java</title><meta data-rh=true property=og:title content="Programmieren mit Java"/><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"/><meta data-rh=true name=twitter:card content=summary_large_image /><meta data-rh=true property=og:url content=https://jappuccini.github.io/java-docs/pr-preview/pr-351/slides/steffen/java-2/00-recap /><meta data-rh=true property=og:locale content=de /><meta data-rh=true name=docusaurus_locale content=de /><meta data-rh=true name=docusaurus_tag content=default /><meta data-rh=true name=docsearch:language content=de /><meta data-rh=true name=docsearch:docusaurus_tag content=default /><link data-rh=true rel=icon href=/java-docs/pr-preview/pr-351/img/favicon.ico /><link data-rh=true rel=canonical href=https://jappuccini.github.io/java-docs/pr-preview/pr-351/slides/steffen/java-2/00-recap /><link data-rh=true rel=alternate href=https://jappuccini.github.io/java-docs/pr-preview/pr-351/slides/steffen/java-2/00-recap hreflang=de /><link data-rh=true rel=alternate href=https://jappuccini.github.io/java-docs/pr-preview/pr-351/slides/steffen/java-2/00-recap hreflang=x-default /><link rel=stylesheet href=/java-docs/pr-preview/pr-351/assets/css/styles.c8d0d76a.css /><script src=/java-docs/pr-preview/pr-351/assets/js/runtime~main.2d1e8cbd.js defer></script><script src=/java-docs/pr-preview/pr-351/assets/js/main.546862cb.js defer></script></head><body class=navigation-with-keyboard><svg style="display: none;"><defs>
<symbol id=theme-svg-external-link viewBox="0 0 24 24"><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div class="reveal reveal-viewport" style=width:100vw;height:100vh><div class=slides><section><section><h2>Agenda</h2><ul><li class=fragment>Klausurnachbesprechung<li class=fragment>Wiederholung<li class=fragment>Fortgeschrittene Programmierung</ul></section></section><section><section><h2>Klausurnachbesprechung</h2></section></section><section><section><h2>Wiederholung</h2></section><section><h2>Datentypen</h2></section><section><h2>Primitive Datentypen</h2><ul><li class=fragment>boolean<li class=fragment>byte, short, <b>int</b>, long<li class=fragment>float, <b>double</b><li class=fragment>char</ul></section><section><h2>Komplexe Datentypen</h2><ul><li class=fragment>String<li class=fragment>jede Klasse</ul><p class=fragment>Tipp: Primitive Datentypen haben keine Methoden</section><section><h2>Methoden</h2></section><section><pre><code class=java>public class Calculator {

  public static int add(int x, int y) {
    return x + y;
  }

}
</code></pre><span class="fragment fade-in-then-out">Rückgabetyp</span><span class="fragment fade-in-then-out">Bezeichner</span><span class="fragment fade-in-then-out">Parameter</span><span class="fragment fade-in-then-out">Methodenrumpf</span></section><section><h2>Operatoren</h2></section><section><h2>Arithmetische Operatoren</h2><pre><code class=java>//...
  public static void main(String[] args) {
    int a = 3;
    int b = 2;
    int addition = a + b; // 5;
    int subtraktion = a - b; // 1;
    int multiplikation = a * b; // 6;
    int division = a / b; // 1, nicht 1.5! Warum?;
    int restwert = a % b; // 1;
  }
//...
</code></pre></section><section><h2>Arithmetische Operatoren II</h2><pre><code class=java>//...
  public static void main(String[] args) {
    int a = 3;
    System.out.println(a++); // Log: 3, Wert: 4
    System.out.println(++a); // Log: 5, Wert: 5
    System.out.println(--a); // Log: 4, Wert: 4
    System.out.println(a--); // Log: 4, Wert: 3
  }
//...
</code></pre></section><section><h2>Vergleichsoperatoren</h2><pre><code class=java>//...
  public static void main(String[] args) {
    boolean result;
    result = 3 == 2; // false 
    result = 3 != 2; // true 
    result = 3 > 2; // true 
    result = 2 >= 2; // true 
    result = 2 &lt; 2; // false 
    result = 2 &lt;= 2; // true 
  }
//...
</code></pre></section><section><h2>Logische Operatoren I - AND</h2><pre><code class=java>//...
  public static void main(String[] args) {
    boolean t = true;
    boolean f = false;
    boolean result;

    result = t && f; // false 
    result = t && t; // true 
    result = f && t; // false 
    result = f && f; // false 
  }
//...
</code></pre></section><section><h2>Logische Operatoren II - OR</h2><pre><code class=java>//...
  public static void main(String[] args) {
    boolean t = true;
    boolean f = false;
    boolean result;

    result = f || t; // true 
    result = t || f; // true 
    result = f || f; // false 
    result = t || t; // true 
  }
//...
</code></pre></section><section><h2>Logische Operatoren III - NOT</h2><pre><code class=java>//...
  public static void main(String[] args) {
    boolean t = true;
    boolean f = false;
    boolean result;

    result = !f; // true 
    result = !t; // false 
  }
//...
</code></pre></section><section><h2>Kontrollstrukturen</h2></section><section><h2>if</h2><pre><code class=java>//...
  public static void main(String[] args) {
    int age = 18;

    if(age >= 18) {
      // Ich krieg alles, was ich will
    } else if(age >= 16) {
      // Ich krieg Bier, Wein, Most &lt;3 und Sekt 
    } else  {
      // Ich krieg Coca Zero
    } 
  }
//...
</code></pre></section><section><h2>switch</h2><pre><code class=java>  public static void greet(char gender) {
    switch(gender) {
      case 'm':
      case 'M':
        // falls man ein Mann ist
        break; 
      case 'F':
        // falls man eine Frau ist
        break; 
      default :
        // falls man divers ist
        break; 
    }
  }
</code></pre></section><section><h2>while-Schleife</h2><pre><code class=java>  public static boolean exists(String brand) {
    String[] cars = { "BMW", "Audi", "Benz" }; 
    boolean found = false; 
    int i = 0; 
    while(!found && i &lt; cars.length) {
      String car = cars[i];
      if(car.equals(brand)) {
        found = true;
      } else {
        i++;
      }
    }
    return found; 
  }
</code></pre></section><section><h2>do-while-Schleife</h2><pre><code class=java>  public static boolean exists(String brand) {
    String[] cars = { "BMW", "Audi", "Benz" }; 
    boolean found = false; 
    int i = 0; 
    do {
      String car = cars[i];
      if(car.equals(brand)) {
        found = true;
      } else {
        i++;
      }
    }
    while(!found && i &lt; cars.length)
    return found; 
  }
</code></pre></section><section><h2>for-Schleife</h2><pre><code class=java>  public static boolean exists(String brand) {
    String[] cars = { "BMW", "Audi", "Benz" } 
    for (int i = 0; i &lt; cars.length; i++) {
      String car = cars[i];
      if(car.equals(brand)) {
        return true;
      }
    }
    return false; 
  }
</code></pre></section><section><h2>for-each-Schleife</h2><pre><code class=java>  public static boolean exists(String brand) {
    String[] cars = { "BMW", "Audi", "Benz" } 
    for (String car : cars) {
      if(car.equals(brand)) {
        return true;
      }
    }
    return false; 
  }
</code></pre></section><section><h2>break und continue</h2><ul><li class=fragment>break beendet die komplette Schleife<li class=fragment>continue überspringt den restlichen Code</ul></section><section><h2>Arrays</h2></section><section><h2>Array</h2><pre><code class=java>  public static void example() {
    String[] cars = { "BMW", "Audi", "Benz" };
    String car;
    car = cars[0]; // lesen aus dem Array
    cars[2] = 'Alfa'; // speichern in ein Array
    String[] twoCars = new String[2]; // Array ohne Inhalt
    int amountOfItems = twoCars.length;
  }
</code></pre></section><section><h2>ArrayList</h2><pre><code class=java>  public static void example() {
    ArrayList&lt;String> cars = new ArrayList&lt;>();
    cars.add('BMW');
    cars.add('Audi');
    cars.add('Benz');
    String car;
    car = cars.get(0); // lesen aus der Liste
    cars.set(2,'Alfa'); // speichern in der Liste
    int amountOfItems = cars.size();
    cars.remove(1); // löschen aus der Liste
  }
</code></pre></section><section><h2>Klassen und Objekte</h2></section><section><h2>Klassen</h2><span class=fragment>Eine Klasse beschreibt gleichartige Objekte durch</span><ul><li class=fragment>Attribute<li class=fragment>Methoden</ul></section><section><h2>Beispiel Klasse</h2><pre><code class=java>public class Human {
  public String firstName;
  public String lastName;
 
  public String getFullName() {
    return firstName + lastName;
  }
}</code></pre></section><section><h2>Objekte</h2><span class=fragment>Ein Objekt ist eine mögliche Ausprägung einer Klasse</span><ul><li class=fragment>konkreter Wert für ein Attribut<li class=fragment>konkretes Verhalten einer Methode</ul></section><section><h2>Beispiel Objekt</h2><pre><code class=java>  Human steffen = new Human();
  steffen.firstName = "Steffen";
  steffen.lastName = "Merk";
  String fullName = steffen.getFullName();
</code></pre></section><section><h2>Konstruktor</h2><ul><li class=fragment>beschreibt die Initialisierung eines Objektes<li class=fragment>Konstruktoren können Überladen werden</ul></section><section><pre><code class=java>public class Car {
  private String color;
  private char engineType;

  public Car(String color) {
    this.color = color;
    this.engineType = 'b';
  }

  public Car(String color, char engineType) {
    this.color = color;
    this.engineType = engineType;
  }
}
</code></pre></section><section><h2>Konstruktor II</h2><ul><li class=fragment>Konstruktoren können andere Konstruktoren verwenden</ul></section><section><pre><code class=java data-line-numbers=|5-7>public class Car {
  private String color;
  private char engineType;

  public Car(String color) {
    this(color, 'b')
  }

  public Car(String color, char engineType) {
    this.color = color;
    this.engineType = engineType;
  }
}
</code></pre></section><section><h2>Vererbung</h2></section><section><h2>Vererbung</h2><p>Durch <b>Generalisierung</b> werden gemeinsame Attribute und Methoden von mehreren Klassen in eine weitere Klasse ausgelagert.</section><section><pre><code class=java>public class Dog {
  public String name;
  public Dog(String name) {
    this.name = name;
  }
  // more Dog specific methods
}
public class Cat {
  public String name;
  public Cat(String name) {
    this.name = name;
  }
  // more Cat specific methods
}
</code></pre></section><section><pre><code class=java>public class Animal {
  public String name;
  public Animal(String name) {
    this.name = name;
  }
}
</code></pre></section><section><pre><code class=java>public class Dog extends Animal {
  public Dog(String name) {
    super(name);
  }
}

public class Cat extends Animal {
  public Cat(String name) {
    super(name);
  }
}
</code></pre></section><section><h2>Schlüsselwörter zur Vererbung</h2><ul><li class=fragment>extends<li class=fragment>super</ul></section><section><h2>Polymorphie</h2></section><section><h2>Polymorphie</h2><p class=fragment>Eine Referenzvariable, die vom Typ einer generalisierten Klasse ist, kann mehrere (poly) Formen annehmen (Unterklassen).<p class=fragment>Eine Referenzvariable vom Typ Animal kann eine Katze oder ein Hund sein.</section><section><h2>Upcast</h2><p class=fragment>Der Referenzvariable einer Oberklasse wird eine Referenzvariable einer Unterklasse zugewiesen.<pre class=fragment><code class=java>Animal animal01 = new Cat();
Animal animal02 = new Dog();
</code></pre></section><section><p>Ist eine Referenzvariable vom Typ einer generalisierten Klasse, können nur die Methoden der generalisierten Klasse verwendet werden.<pre><code class=java>Animal animal01 = new Dog();
animal01.name = 'Bello'; // funktioniert
animal01.bark(); // funktioniert nicht 
</code></pre></section><section><h2>Downcast</h2><p class=fragment>Der Referenzvariable einer Oberklasse wird eine Referenzvariable einer Unterklasse zugewiesen.<pre class=fragment><code class=java>Animal animal01 = new Dog();
Dog dog01 = (Dog) animal01;
dog01.bark(); // funktioniert
</code></pre></section><section><h2>instanceof operator</h2><pre><code class=java>Animal animal01 = new Dog();
if (animal01 instanceof Dog) {
   // hundespezifischer Quellcode
   Dog bello = (Dog) animal01;
   bello.bark();
}</code></pre></section><section><h2>Modifier</h2></section><section><h2>Public Modifier - Klasse</h2><pre><code class=java>public class Dog {
  //...
}
</code></pre><p>Klasse kann überall im Projekt verwendet werden.</section><section><h2>Kein Modifier - Klasse</h2><pre><code class=java>class Dog {
  //...
}
</code></pre><p>Klasse kann nur im selben Paket verwendet werden.</section><section><h2>Abstract Modifier - Klasse</h2><pre><code class=java>public abstract class Dog {
  //...
}
</code></pre><p>Ein Objekt dieser Klasse kann nicht instanziiert werden.</section><section><h2>Final Modifier - Klasse</h2><pre><code class=java>public final class Dog {
  //...
}
</code></pre><p>Von dieser Klasse kann nicht geerbt werden.</section><section><h2>Public Modifier - Attribut</h2><pre><code class=java>public class Dog {
  public String name;
  //...
}
</code></pre><p>Das Attribut kann immer geändert werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.name = "Steffen"; // funktioniert

public class MonsterDog extends Dog {
 //...
 public void setName(String name) {
   this.name = name; // funktioniert
 }
 //...
}
</code></pre></section><section><h2>Private Modifier - Attribut</h2><pre><code class=java>public class Dog {
  private String name;
  //...
  public void setName(String name) {
    this.name = name; // funktioniert
  }
}
</code></pre><p>Das Attribut kann innerhalb der Klasse geändert werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.name = "Steffen"; // funktioniert nicht

public class MonsterDog extends Dog {
 //...
 public void setName(String name) {
   this.name = name; // funktioniert nicht
 }
 //...
}
</code></pre></section><section><h2>Protected Modifier - Attribut</h2><pre><code class=java>public class Dog {
  protected String name;
  //...
  public void setName(String name) {
    this.name = name; // funktioniert
  }
}
</code></pre><p>Das Attribut kann innerhalb der Klasse und von allen erbenden Klassen geändert werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.name = "Steffen"; // funktioniert nicht

public class MonsterDog extends Dog {
 //...
 public void setName(String name) {
   this.name = name; // funktioniert
 }
 //...
}
</code></pre></section><section><h2>Final Modifier - Attribut</h2><pre><code class=java>public class Dog {
  public final String name;
  //...
  public Dog(String name) {
    this.name = name; // funktioniert
  }

  public void setName(String name) {
    this.name = name; // funktioniert nicht
  }
}
</code></pre><p>Das Attribut kann nur im Konstruktor geändert werden.</section><section><pre><code class=java>Dog bello = new Dog("Marianna");
bello.name = "Steffen"; // funktioniert nicht

public class MonsterDog extends Dog {
 //...
 public void setName(String name) {
   this.name = name; // funktioniert nicht
 }
 //...
}
</code></pre></section><section><h2>Static Modifier - Attribut</h2><pre><code class=java>public class Dog {
  public static boolean hasHat = false;
  //...
}
</code></pre><p>Das Attribut gehört zu der Klasse und nicht zu einem Objekt.</section><section><pre><code class=java>Dog bello = new Dog();
bello.hasHat = true; // funktioniert nicht
Dog.hasHat = true; // funktioniert

public class MonsterDog extends Dog {
 //...
 public void setHat(boolean hasHat) {
   this.hasHat = hasHat; // funktioniert nicht
   Dog.hasHat = hasHat; // funktioniert
 }
 //...
}
</code></pre></section><section><h2>Public Modifier - Methode</h2><pre><code class=java>public class Dog {
  public void bark() {
    //...
  }
  //...
}
</code></pre><p>Die Methode kann immer verwendet werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.bark(); // funktioniert

public class MonsterDog extends Dog {
 //...
 public void attack() {
   this.bark(); // funktioniert
 }
 //...
}
</code></pre></section><section><h2>Private Modifier - Methode</h2><pre><code class=java>public class Dog {
  private void bark() {
    //...
  }
  //...
}
</code></pre><p>Die Methode kann innerhalb der Klasse verwendet werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.bark(); // funktioniert nicht

public class MonsterDog extends Dog {
 //...
 public void attack() {
   this.bark(); // funktioniert nicht
 }
 //...
}
</code></pre></section><section><h2>Protected Modifier - Methode</h2><pre><code class=java>public class Dog {
  protected void bark() {
    //...
  }
  //...
}
</code></pre><p>Das Attribut kann innerhalb der Klasse und von allen erbenden Klassen verwendet werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.bark(); // funktioniert nicht

public class MonsterDog extends Dog {
 //...
 public void attack() {
   this.bark(); // funktioniert
 }
 //...
}
</code></pre></section><section><h2>Final Modifier - Methode</h2><pre><code class=java>public class Dog {
  public final void bark() {
    //...
  }
  //...
}
</code></pre><p>Die Methode kann nicht überschrieben werden.</section><section><pre><code class=java>public class MonsterDog extends Dog {
 //...
 public void bark() { // funktioniert nicht 
   //...
 }
 //...
}
</code></pre></section><section><h2>Static Modifier - Methode</h2><pre><code class=java>public class Dog {
  public static hasHat = true;
  public static isCool = true;
  public static boolean isCoolAndHasHat() {
    return Dog.isCool && Dog.hasHat;
  }
  //...
}
</code></pre><p>Die Methode gehört zu der Klasse und nicht zu einem Objekt. Es kann nur auf statische Attribute zugegriffen werden.</section><section><pre><code class=java>Dog bello = new Dog();
bello.isCoolAndHasHat(); // funktioniert nicht
Dog.isCoolAndHasHat(); // funktioniert

public class MonsterDog extends Dog {
 //...
 public void attack() {
   this.isCoolAndHasHat(); // funktioniert nicht
   Dog.isCoolAndHasHat(); // funktioniert
 }
 //...
}
</code></pre></section><section><h2>Abstract Modifier - Methode</h2><pre><code class=java>public abstract class Animal {
  //...
  public abstract void makeSound();
}
</code></pre><p>Die Methode muss von der erbenden Klasse implementiert werden. Abstrakte Methoden können nur in abstrakten Klassen definiert werden.</section><section><pre><code class=java>public class MonsterDog extends Dog {
 // funktioniert nicht, makeSound muss implementiert werden
}
</code></pre></section><section><h2>Enumeration</h2></section><section><h2>Enumeration</h2><p>Eine Enumeration ist eine Klasse mit Attributen und Methoden. Sie definiert zusätzlich alle möglichen Ausprägungen dieser Klasse.</section><section><h2>Enumeration implementieren</h2><pre><code class=java>public enum Gender {
 MALE("Mann"),
 FEMALE("Frau"),
 DIVERS("Divers");
 
 public final String text;
 
 Gender(String text) {
   this.text = text;
 }
 
 public boolean isBinary() {
   return this == Gender.MALE || this == Gender.FEMALE;
 }
}
</code></pre></section><section><h2>Enumeration als Typ verwenden</h2><pre><code class=java>public class Human {
 public final Gender gender;
 
 public Human(Gender gender) {
   this.gender = gender;
 }
 public doSomethingBinaryRelated() {
   if(this.gender.isBinary())
   //...
 }
}
</code></pre></section><section><h2>Enumeration als Wert setzen</h2><pre><code class=java>Human steffen = new Human(Gender.MALE);
</code></pre></section><section><h2>Interfaces</h2></section><section><h2>Interfaces</h2><p>Definieren Methoden unabhängig von der Vererbungshierarchie.<p class=fragment>Dient als Schnittstelle zwischen Ersteller und Verwender einer Funktionalität.</section><section><h2>Interface (Ersteller)</h2><pre><code data-line-numbers=1-3|6|7,11 class=java>public interface Item {
  public String getName(); 
}

public class ShoppingList {
  ArrayList&lt;Item> items = new ArrayList&lt;>();
  public void add(Item item) {
    this.items.add(item);
  }
  public void print() {
    for(Item item : items) {
      System.out.println(item.getName();
    }
  }
}
</code></pre></section><section><h2>Interface (Verwender) I</h2><pre><code data-line-numbers=1|10-12 class=java>public class Human implements Item {
  public final String firstName;
  public final String lastName;
  
  public Human(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  public String getName() {
    return firstName + " " + lastName;
  }
}
</code></pre></section><section><h2>Interface (Verwender) II </h2><pre><code class=java>ShoppingList shoppingList = new ShoppingList();
Human steffen = new Human("Steffen", "Merk");
shoppingList.add(steffen);
shoppingList.print(); // "Steffen Merk"
</code></pre></section><section><h2>Comparator</h2></section><section><h2>Comparator</h2><p class=fragment>Definiert wie eine Liste von Elementen sortiert wird.<p class=fragment>Vergleicht immer zwei Elemente miteinander, bei dem angegeben wird, wo das erste Element im Vergleich zum zweiten Element positioniert wird (Zahlenstrahl).</section><section><h2>Comparator implementieren</h2><pre><code class=java>public class AgeAscComparator implements Comparator&lt;Human> {
  
  public int compare(Human h1, Human h2) {
    if(h1.getAge() > h2.getAge()) {
     return 1;
    } else if (h1.getAge() &lt; h2.getAge()) {
      return -1;
    } else {
      return 0;
    } 
  }
}
</code></pre></section><section><h2>Comparator verwenden</h2><pre><code class=java>ArrayList&lt;Human> developers = new ArrayList&lt;>();
developers.add(new Human(28));
developers.add(new Human(24));
Collections.sort(developers, new AgeAscComparator());
</code></pre></section><section><h2>Exceptions</h2></section><section><h2>Exceptions</h2><p class=fragment>Sind Fehler, die während der Ausführung des Programms auftreten können und dienen zur Kommunikation.<p class=fragment>Fehler können mitgeteilt (throws) und verarbeitet werden (catch).</section><section><h2>Exception implementieren</h2><pre><code data-line-numbers=1-9|1|6 class=java>public class TooYoungException extends Exception {
  
  public final int yearsTillAllowed;
  
  public TooYoungException(int yearsTillAllowed) {
    super();
    this.yearsTillAllowed = yearsTillAllowed;
  }
}
</code></pre></section><section><h2>Exception auslösen</h2><pre><code data-line-numbers=1-9|4|6 class=java>public class ShoppingList {
  Human buyer;
  //...
  public addItem(Item item) throws TooYoungException {
    if(item.isAlcohol() && this.buyer.getAge() &lt; 21) {
      throw new TooYoungException(21 - buyer.getAge());
    }
  }
}
</code></pre></section><section><h2>Exception behandeln</h2><pre><code data-line-numbers=1-13|5-7|7-9|9-11 class=java>public class Main {
  public static void main(String[] args) {
    ShoppingList sl = new ShoppingList();
    Beer corona = new Beer();
    try {
      sl.add(corona);
    } catch (TooYoungException e) {
      System.out.println("Du bist" + e.yearsTillAllowed + "zu jung");
    } finally {
      System.out.println("Einkauf beendet. (Immer)");
    }
  }
}
</code></pre></section><section><h2>Klassendiagramme (Doku)</h2></section></section><section><section><h2>Organisatorsiches</h2></section><section><h2>Fortgeschrittene Programmierung</h2><ul><li class=fragment>Algorithmen und Datenstrukturen<li class=fragment>Generische Programmierung<li class=fragment>Funktionale Programmierung</ul></section><section><h2>Prüfungsleistungen</h2><ul><li class=fragment>Projektbericht (50 Punkte)<li class=fragment>Klausur am PC (50 Punkte)</ul></section><section><h2>Abgabetermine in Moodle</h2><ul><li class=fragment>30.04.2025 - Problemstellung und Daten<li class=fragment>30.05.2025 - Projektbericht</ul></section><section><h2>Projektbericht - Problem</h2><ul><li class=fragment>findet ein Problem (im Unternehmen)<li class=fragment>(er)findet dazu Daten<li class=fragment>mindestens eine Verknüpfung<li class=fragment>keine doppelten Themen (Selbstorganisiert)</ul></section><section><h2>Projektbericht - Abgabe I</h2><ul><li class=fragment>Problembeschreibung (.txt)<li class=fragment>20 Datensätze mit Überschrift (.csv)<li class=fragment>Abgabe in Moodle 30.04 23:59</ul></section><section><h2>Projektbericht - Abgabe II</h2><ul><li class=fragment>Erklärung am 28.04<li class=fragment>Abgabe in Moodle 30.05 23:59</ul></section><section><h2>Klausur am PC</h2><ul><li class=fragment>Ablauf wie Klausur<li class=fragment>VSCode anstatt Notepad++</ul></section></section><section><section><h2>Rest of the day</h2><ul><li class=fragment>Wiederholung<li class=fragment>Entwicklungsumgebung einrichten<li class=fragment>Individuelle Klausureinsicht</ul></section></section></div></div></div></body>